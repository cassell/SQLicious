<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Sqlicious : SQLicious is a PHP Database ORM and abstraction layer for MySQL that handles generating an object model from your database schema. Its powerful closure based query processing and ability to handle large datasets make it powerful and flexible. It's included web interface and ease of development make it a joy to use." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Sqlicious</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/cassell/SQLicious">View on GitHub</a>

          <img style="border:none; margin: 0px 0px 30px -5px; -webkit-box-shadow:none; box-shadow:none; width: 400px" src="images/sqlicious-logo-white.png" alt="Sqlicious">
		  <h2 id="project_tagline" style="margin: 0;">SQLicious is a PHP Database ORM and abstraction layer for MySQL that handles generating an object model from your database schema. Its powerful closure based query processing and ability to handle large datasets make it powerful and flexible. It's included web interface and ease of development make it a joy to use.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/cassell/SQLicious/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/cassell/SQLicious/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>What is so special about SQLicious?</h3>
		
		<p>The ten features that make SQLicious easy and powerful are:</p>
		
		<ol>
			<li>Closure based query processing that lets you handle data efficently and fully customizable manner</li>
			<li>Web UI for code generation and fast paced development. It helps with common programming tasks (object creation, class stubs, queries).</li>
			<li>Queries can easily be limited to a subset of fields in a table ("select first_name, last_name from table" vs. "select * from table"). You can still use objects when using a subset of the fields.</li>
			<li>UPDATEs are minimal and only changed columns are updated</li>
			<li>Buffered queries for performance and Unbuffered queries for processing huge datasets while staying memory safe</li>
			<li>Factories and Objects are Automatically Generated</li>
			<li>You can extend the Factories and Objects to encapsulate the logic of a model</li>
			<li>Process any SQL query (multiple tables and joins) using the same closure based process model</li>
			<li>Handles the CRUD</li>
			<li>Convert Timezones Using MySQL Timezone Tables</li>
		</ol>
		
<article class="markdown-body entry-content" itemprop="mainContentOfPage">

<a name="crud-creating-reading-updating-and-deleting" class="anchor" href="#crud-creating-reading-updating-and-deleting"><span class="mini-icon mini-icon-link"></span></a><h3>CRUD: Creating, Reading, Updating, and Deleting</h3>

<p>Creating a new record</p>

<pre><code>$user = new User();
$user-&gt;setFirstName('Ada');
$user-&gt;setLastName('Lovelace');
$user-&gt;setEmail('lovelace@example.com');
$user-&gt;save();
echo $user-&gt;getId() // will print the new primary key
</code></pre>

<p>Finding an object with id 17.</p>

<pre><code>$f = new UserFactory();
$user = $f-&gt;getObject(17);

// shorthand
$user = User::findId(17);
</code></pre>

<p>Querying for objects</p>

<pre><code>$f = new UserFactory();
$f-&gt;addBinding(new EqualsBinding("archived","0"));
$users = $f-&gt;getObjects();
</code></pre>

<p>Contains searches for objects</p>

<pre><code>// looking for users with example.com in their email
$f = new UserFactory();
$f-&gt;addBinding(new ContainsBinding("email","example.com"));
$users = $f-&gt;getObjects();
</code></pre>

<p>String based binding clauses</p>

<pre><code>// looking for users with example.com in their email
$f = new UserFactory();
$f-&gt;addBinding("user.archived != 1");
$users = $f-&gt;getObjects();
</code></pre>

<p>Updating a record.</p>

<pre><code>$user = User::findId(17);
$user-&gt;setArchived(1);
$user-&gt;save();
</code></pre>

<p>Deleting a record.</p>

<pre><code>$user = User::findId(18);
$user-&gt;delete();
</code></pre>

<p>Limit the query to the first 20 rows</p>

<pre><code>$f = new UserFactory();
$f-&gt;setLimit(20);
$users = $f-&gt;getObjects();
</code></pre>

<p>Running a count query</p>

<pre><code>$f = new UserFactory();
$f-&gt;addArchivedFalseBinding()
$count = $f-&gt;count(); // count of all not archived users
</code></pre>

<h3>
<a name="performance" class="anchor" href="#performance"><span class="mini-icon mini-icon-link"></span></a>Performance</h3>

<p>Limiting the fields that are pulled back from the database. You can still use objects</p>

<pre><code>$f = new UserFactory();
$f-&gt;setSelectFields("first_name","last_name","email");
$users = $f-&gt;getObjects();
</code></pre>

<p>Getting a JSON ready array</p>

<pre><code>$f = new UserFactory();
$f-&gt;setSelectFields("first_name","last_name","email");
$userJSON = $f-&gt;getJSON(); // returns an an array of PHP objects that can be encoded to  [ { 'id' : 1, 'firstName' : 'John', 'lastName' : 'Doe', 'email' : 'doe@example.com'}, ... ]
</code></pre>

<h3>
<a name="closures" class="anchor" href="#closures"><span class="mini-icon mini-icon-link"></span></a>Closures</h3>

<p>Process each row queried with an anonymous function. To iterate over very large datasets without hitting memory constraints use unbufferedProcess()</p>

<pre><code>$f = new UserFactory();
$f-&gt;process(function($user)
{
	if(!validate_email($user-&gt;getEmail()))
	{
		$user-&gt;setEmail('');
		$user-&gt;save();
	}
});
</code></pre>

<p>Getting count of Rows before process</p>

<pre><code>$f = new UserFactory();
$f-&gt;query();
$countOfUsers = $f-&gt;getNumberOfRows();
$f-&gt;process(function($user)
{
	if(!validate_email($user-&gt;getEmail()))
	{
		$user-&gt;setEmail('');
		$user-&gt;save();
	}
});
$f-&gt;freeResult();
</code></pre>

<h3>
<a name="memory-safe-outputs-works-with-billions-of-rows" class="anchor" href="#memory-safe-outputs-works-with-billions-of-rows"><span class="mini-icon mini-icon-link"></span></a>Memory Safe Outputs (works with billions of rows)</h3>

<p>Output directly to CSV</p>

<pre><code>$f = new UserFactory();
$f-&gt;outputCSV();
</code></pre>

<p>Output directly to JSON</p>

<pre><code>$f = new UserFactory();
$f-&gt;outputJSONString();
</code></pre>

<h3>
<a name="memory-safe-closures" class="anchor" href="#memory-safe-closures"><span class="mini-icon mini-icon-link"></span></a>Memory Safe Closures</h3>

<p>Unbuffered Processing of large datasets (will potentially lock the table while processing)</p>

<pre><code>$f = new UserFactory(); // imagine a table with millions of rows
$f-&gt;unbufferedProcess(function($user)
{
	if(!validate_email($user-&gt;getEmail()))
	{
		$user-&gt;setEmail('');
		$user-&gt;save();
	}
});
</code></pre>

<h3>
<a name="data-processors" class="anchor" href="#data-processors"><span class="mini-icon mini-icon-link"></span></a>Data Processors</h3>

<p>Data processors are great for processing the results from an entirely custom SELECT query with closures.</p>

<p>Buffered Queries for Speed  </p>

<pre><code>$p = new DatabaseProcessor('example');
$p-&gt;setSQL('select first_name, last_name from user');
$p-&gt;process(function($row)
{
	echo $row['first_name'];
	print_r($row);

});
</code></pre>

<p>Unbuffered for Large Datasets</p>

<pre><code>$p = new DatabaseProcessor('example');
$p-&gt;setSQL('select first_name, last_name from user');
$p-&gt;unbufferedProcess(function($row)
{
	echo $row['first_name'];
});
</code></pre>

<h3>
<a name="other-flexibile-queries" class="anchor" href="#other-flexibile-queries"><span class="mini-icon mini-icon-link"></span></a>Other flexibile queries</h3>

<p>Find method for writing a custom where clause (returns objects)</p>

<pre><code>$f = new UserFactory();
$users = $f-&gt;find("where archived != 1 and email like '%@example.com'");
</code></pre>

<p>Count query with custom where clause (returns an integer)</p>

<pre><code>$f = new UserFactory();
$countOfUsers = $f-&gt;getCount("where archived != 1 and email like '%@example.com'");
</code></pre>

<h3>
<a name="converting-timezones" class="anchor" href="#converting-timezones"><span class="mini-icon mini-icon-link"></span></a>Converting Timezones</h3>

<pre><code>$f = new UserLoginFactory();
$centralTime = $f-&gt;convertTimezone('2012-02-23 04:10PM', 'US/Eastern',  'US/Central'); // usage: ($dateTime,$sourceTimezone,$destTimezone). $dateTime may be string or time(), returns a timestamp
</code></pre>

<h3>
<a name="setup" class="anchor" href="#setup"><span class="mini-icon mini-icon-link"></span></a>Setup</h3>

<ol>
<li>Download the source code</li>
<li>Use the example.config.inc.php to build your config.inc.php</li>
<li>Make sure the generator has write access to the folders you specify in config</li>
<li>Generate the DAO using the web UI</li>
<li>require_once('sqlicious.inc.php') in your project</li>
<li>require_once or include any other generated factories that you need in your project</li>
</ol><h1>
<a name="requirements" class="anchor" href="#requirements"><span class="mini-icon mini-icon-link"></span></a>Requirements</h1>

<ul>
<li>PHP 5.3 or greater</li>
<li>MySQL</li>
</ul>

</article>
		
	</div>

<!-- FOOTER  -->
<div id="footer_wrap" class="outer">
	<footer class="inner">
	<p class="copyright">Sqlicious maintained by <a href="https://github.com/cassell">cassell</a></p>
	<p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
	</footer>
</div>

    

  </body>
</html>
