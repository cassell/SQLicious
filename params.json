{"name":"Sqlicious","tagline":"SQLicious is a PHP Database ORM and abstraction layer for MySQL that handles generating an object model from your database schema. Its powerful closure based query processing and ability to handle large datasets make it powerful and flexible. It's included web interface and ease of development make it a joy to use.","body":"![SQLicious Logo](http://static.andrewcassell.com/github/sqlicious/SQLicious.png)\r\n\r\nSQLicious\r\n=============\r\n\r\nSQLicious is a PHP Active Record ORM that generates an object models from your MySQL database. Its powerful closure based query processing and ability to handle large datasets make it powerful and flexible. Its included web interface and ease of development make it a joy to use.\r\n\r\nThe features that make SQLicious easy and powerful are:\r\n\r\n1. Web UI for code generation and fast paced development. It helps with common programming tasks (object creation, APIs, class stubs, queries). Command line version also available.\r\n1. Easily output data as JSON for APIs\r\n1. Queries can easily be limited to a subset of fields in a table (\"select first_name, last_name from table\" vs. \"select * from table\"). You can still use objects when using a subset of the fields.\r\n1. SQL UPDATEs are minimal and only changed columns are updated\r\n1. Closure based query processing that lets you handle data efficiently and in a fully customizable manner\r\n1. Buffered queries for performance and Unbuffered queries for processing huge datasets while staying memory safe\r\n1. You can extend the Factories and Objects to encapsulate the logic of a model\r\n1. Process any SQL query (multiple tables and joins) using the same closure based process model. Easily output the results to an Array or JSON\r\n1. Handles the CRUD (Creating, Reading, Updating, and Deleting)\r\n1. Convert Timezones Using MySQL Timezone Tables\r\n1. Generated Code is creating using Mustache Templates\r\n\r\n\r\nCRUD: Creating, Reading, Updating, and Deleting\r\n==============\r\n\r\nCreating a new record\r\n\t\r\n\t$user = new User();\r\n\t$user->setFirstName('Ada');\r\n\t$user->setLastName('Lovelace');\r\n\t$user->setEmail('lovelace@example.com');\r\n\t$user->save();\r\n\techo $user->getId() // will print the new primary key\r\n\t\r\nFinding an object with id 17.\r\n\t\r\n\t$f = new UserFactory();\r\n\t$user = $f->getObject(17);\r\n\t\r\n\t// shorthand\r\n\t$user = User::findId(17);\r\n\r\nQuerying for objects\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->addBinding(new EqualsBinding(\"archived\",\"0\"));\r\n\t$users = $f->getObjects();\r\n\t\r\nContains searches for objects\r\n\t\r\n\t// looking for users with example.com in their email\r\n\t$f = new UserFactory();\r\n\t$f->addBinding(new ContainsBinding(\"email\",\"example.com\"));\r\n\t$users = $f->getObjects();\r\n\t\r\n\t\r\nString based binding clauses\r\n\t\r\n\t// looking for active users\r\n\t$f = new UserFactory();\r\n\t$f->addBinding(\"user.archived != 1\");\r\n\t$users = $f->getObjects();\r\n\t\r\nUpdating a record.\r\n\t\r\n\t$user = User::findId(17);\r\n\t$user->setFirstName(\"John\");\r\n\t$user->save();\r\n\t\r\nDeleting a single record.\r\n\t\r\n\t$user = User::findId(18);\r\n\t$user->delete();\r\n\r\nDeleting multiple records.\r\n\r\n\t// delete archived users\r\n\t$f = new UserFactory();\r\n\t$f->addBinding(new EqualsBinding(\"archived\",\"1\"));\r\n\t$f->delete();\r\n\t\r\nLimit the query to the first 20 rows\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->setLimit(20);\r\n\t$users = $f->getObjects();\r\n\t\r\nRunning a count query\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->addArchivedFalseBinding()\r\n\t$count = $f->count(); // count of all not archived users\r\n\t\r\n\r\nPerformance\r\n=============\r\nLimiting the fields that are pulled back from the database. You can still use objects\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->setSelectFields(\"first_name\",\"last_name\",\"email\");\r\n\t$users = $f->getObjects();\r\n\t\r\nGetting a JSON ready array\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->setSelectFields(\"first_name\",\"last_name\",\"email\");\r\n\t$userJSON = $f->getJSON(); // returns an an array of PHP objects that can be encoded to  [ { 'id' : 1, 'firstName' : 'John', 'lastName' : 'Doe', 'email' : 'doe@example.com'}, ... ]\r\n\t\r\n\r\nClosures\r\n============\r\nProcess each row queried with a closure(anonymous function). Iterate over very large datasets without hitting memory constraints use unbufferedProcess()\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->process(function($user)\r\n\t{\r\n\t\tif(!validate_email($user->getEmail()))\r\n\t\t{\r\n\t\t\t$user->setEmail('');\r\n\t\t\t$user->save();\r\n\t\t}\r\n\t});\r\n\r\nGetting count of Rows before process\r\n\t\r\n\t$f = new UserFactory();\r\n\t$result = $f->getMysqlResult();\r\n\t$countOfUsers = $f->getNumberOfRowsFromResult($result);\r\n\t$f->process(function($user)\r\n\t{\r\n\t\tif(!validate_email($user->getEmail()))\r\n\t\t{\r\n\t\t\t$user->setEmail('');\r\n\t\t\t$user->save();\r\n\t\t}\r\n\t});\r\n\t$f->freeResult();\r\n\r\n<!--\r\nMemory Safe Outputs (works with billions of rows)\r\n============\t\r\n\r\nOutput directly to CSV\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->outputCSV();\r\n\t\r\nOutput directly to JSON\r\n\t\r\n\t$f = new UserFactory();\r\n\t$f->outputJSONString();\r\n-->\r\n\r\nMemory Safe Closures\r\n============\r\n\t\r\nUnbuffered Processing of large datasets\t(will potentially lock the table while processing)\r\n\t\r\n\t$f = new UserFactory(); // imagine a table with millions of rows\r\n\t$f->unbufferedProcess(function($user)\r\n\t{\r\n\t\tif(!validate_email($user->getEmail()))\r\n\t\t{\r\n\t\t\t$user->setEmail('');\r\n\t\t\t$user->save();\r\n\t\t}\r\n\t});\r\n\t\r\nData Processors\r\n=============\r\n\r\nData processors are great for processing the results from an entirely custom SELECT query with closures.\r\n\r\nBuffered Queries for Speed\t\r\n\t\r\n\t$p = new DatabaseProcessor('example');\r\n\t$p->setSQL('select first_name, last_name from user');\r\n\t$p->process(function($row)\r\n\t{\r\n\t\techo $row['first_name'];\r\n\t\tprint_r($row);\r\n\t\t\r\n\t});\r\n\r\nUnbuffered for Large Datasets\r\n\r\n\t$p = new DatabaseProcessor('example');\r\n\t$p->setSQL('select first_name, last_name from user');\r\n\t$p->unbufferedProcess(function($row)\r\n\t{\r\n\t\techo $row['first_name'];\r\n\t});\r\n\r\n\t\r\nOther flexibile queries\r\n============\r\n\t\r\nFind method for writing a custom where clause (returns objects)\r\n\t\r\n\t$f = new UserFactory();\r\n\t$users = $f->findObjectWhere(\"where archived != 1 and email like '%@example.com'\");\r\n\t\r\n\t\r\n<!--\r\nDemo is offline.\r\n\r\nWeb UI\r\n===========\r\nhttp://demo.sqlicious.com\r\n->>\r\n\r\nConverting Timezones\r\n=============\r\n\r\n\t// Note requires time zones installed in mysql database\r\n\t// usage: ($dateTime,$sourceTimezone,$destTimezone). $dateTime may be string or time(), returns a timestamp\r\n\t$f = new UserLoginFactory();\r\n\t$centralTime = $f->convertTimezone('2012-02-23 04:10PM', 'US/Eastern',  'US/Central');\r\n\r\n\r\nComposer (Packagist)\r\n=============\r\nhttps://packagist.org/packages/sqlicious/sqlicious\r\n\r\nSetup\r\n=============\r\n\r\n1. Download the source code (or use composer)\r\n2. Use the example.config.inc.php to build your config.inc.php\r\n3. Make sure the generator has write access to the folders you specify in config\r\n4. Generate the DAO using the web UI or command line\r\n5. require_once('sqlicious.inc.php') in your project\r\n6. require_once or include any other generated factories that you need in your project (suggestion: use an autoloader)\r\n\r\nRequirements\r\n=============\r\n* PHP 5.3 or greater\r\n* MySQL","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}